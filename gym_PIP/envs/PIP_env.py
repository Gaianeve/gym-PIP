# -*- coding: utf-8 -*-
"""Real_Mega_FufiEnv.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/github/Gaianeve/Real_Mega_Fufi/blob/main/Robot/Real_Mega_FufiEnv.ipynb

#Environment for PIP  ğŸ›º ğŸš€ ğŸ¦¾


In this notebook there's the environment for our PIP ğŸ§ ğŸ“š

ğŸ”– ğŸ¦¤ *Code based on the standard pybullet [CartPole environment](https://github.com/bulletphysics/bullet3/blob/master/examples/pybullet/gym/pybullet_envs/bullet/cartpole_bullet.py)*


---

---

* ğŸ®  **Actions space**: Continous action space, an array of two element indicating the force/acceleration to be applied on x,y (sign and abs value).

* ğŸ® **Observations space**: 3 LVDT measures, that is the 3 leg position in the form (x,y,z), and the two angle Î¸, which is the angle arond z.

  1. â•  **FORMAT**
  I'm ignoring z coordinate and the tilt angle Î¨, cause the cart must stay on the plane, not move in vertical, nore tilt with respect to the plane.
  **Obeservations** : (x,y,z,yaw) for all legs

  2. â— **CONSTRAINTS**:
  Leg next position with rispect to the previous one should not differ for more than 2 mm, that is:
      *distance < 0.002 m*

Just to be sure,let's just put a constrain also to the angle around z: difference between the current and previous should not be more than 2mm / rdisco = 0.005 rad.
Not needed because it's the same constraint of the position, but just in case.

ğŸ›‘ This notebook needs the gitPython packege to be installed, otherwise it wont work
"""

#!pip install GitPython
#!pip install pybullet

import os, inspect

currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
parentdir = os.path.dirname(os.path.dirname(currentdir))
os.sys.path.insert(0, parentdir)

#useful libraries
import logging
import math
import random
import numpy as np
import time
import subprocess

#reinforcement
import gym
from gym import spaces
from gym.utils import seeding

# physics simulator
import pybullet as p
import pybullet_data as pd
from pybullet_utils import bullet_client as bc
from pkg_resources import parse_version

#get git repo
import git

logger = logging.getLogger(__name__)


class RealMegaFufiEnv(gym.Env):
  metadata = {'render.modes': ['human', 'rgb_array'], 'video.frames_per_second': 50}

  def __init__(self, renders=False):
    # set the render
    self._renders = renders
    self._render_height = 200
    self._render_width = 320
    self._physics_client_id = -1

    #set limits for actions and observations
    self.threshold_distance = 0.002
    self.threshold_yaw = 0.005

    high = np.array(
        [
          np.finfo(np.float64).max, np.finfo(np.float64).max, np.finfo(np.float64).max, self.threshold_yaw * 2, #LVDT 1
          np.finfo(np.float64).max, np.finfo(np.float64).max, np.finfo(np.float64).max, self.threshold_yaw * 2, #LVDT 2
          np.finfo(np.float64).max, np.finfo(np.float64).max, np.finfo(np.float64).max, self.threshold_yaw * 2, #LVDT 3
        ],
        dtype=np.float64,
        )

    self.observation_space = spaces.Box(-high, high, dtype=np.float64)

    action_lim = np.finfo(np.float64).max

    # force may be applied in the 2 direction of xy plane. Should always be 0 in the z direction
    self.action_space = spaces.Box(low=-action_lim, high=action_lim, shape=(2,), dtype=np.float64)

    self.seed()

    # start the bullet physics server and initialize things up
    self.reset()
    self.viewer = None
    self._configure()

  def _configure(self, display=None):
    self.display = display

  def seed(self, seed=None):
    self.np_random, seed = seeding.np_random(seed)
    return [seed]

  #load model in pybullet already with material defined
  def load_pippa(self):
    # Getting git repo for PIP model
    repo_url = 'https://github.com/Gaianeve/Real_Mega_Fufi.git'
    repo_name = 'Real_Mega_Fufi'

    if not os.path.exists(repo_name):
        git.Repo.clone_from(repo_url, repo_name)
        print(f'Repository {repo_name} cloned successfully.')
    else:
        print(f'Repository {repo_name} already exists.')

    # saving PIP urdf directory for the model
    pippa_path = os.path.join(repo_name, 'Robot', 'PIPPA')
    if os.path.exists(pippa_path):
        os.chdir(pippa_path)
        print(f'Changed directory to {pippa_path}.')
    else:
        print(f'Path {pippa_path} does not exist.')

    ## -------------------------------------------------------------------------------------
    #load model in pybullet
    useFixedBase = False
    flags = p.URDF_INITIALIZE_SAT_FEATURES
    plane_pos = [0,0,-0.1]
    plane = p.loadURDF("plane.urdf", plane_pos, flags = flags, useFixedBase=useFixedBase)

    # position of the base of the model
    PIP_position = [0,0,1.043]
    orientation  = [np.pi,0,0]
    PIP_orientation = p.getQuaternionFromEuler(orientation)

    self.PIPPA_id = p.loadURDF("PIPPA.urdf",basePosition = PIP_position,baseOrientation = PIP_orientation,\
                          useFixedBase=useFixedBase)
    print(f"pippa_id for environment instance: {self.PIPPA_id}")

    #find link names and indexes
    self.link_name_to_index = {p.getBodyInfo(self.PIPPA_id)[0].decode('UTF-8'):-1,}
    print(f"dictionaries of name-index links: {self.link_name_to_index}")

    for id in range(p.getNumJoints(self.PIPPA_id)):
      name = p.getJointInfo(self.PIPPA_id, id)[12].decode('UTF-8')
      self.link_name_to_index[name] = id

    ## ------------------------------------------------------------------------------------------------
    ## define material for PIP link

    # AL 6082 (Alluminio)
    lateralFriction_Al = 0.3
    restitution_Al = 0.2
    rollingFriction_Al = 0.001
    spinningFriction_Al = 0.01
    linearDamping_Al = 0.04
    angularDamping_Al = 0.1
    contactStiffness_Al = 3e6
    contactDamping_Al = 800

    # AISI 304 (Acciaio Inox)
    lateralFriction_AISI = 0.4
    restitution_AISI = 0.1
    rollingFriction_AISI = 0.001
    spinningFriction_AISI= 0.05
    linearDamping_AISI = 0.03
    angularDamping_AISI = 0.1
    contactStiffness_AISI = 8e6
    contactDamping_AISI = 1500

    # Acciaio Maraging (MaragiÃ  per gli amici)
    lateralFriction_Mar = 0.3
    restitution_Mar = 0.2
    rollingFriction_Mar = 0.001
    spinningFriction_Mar = 0.02
    linearDamping_Mar = 0.04
    angularDamping_Mar = 0.15
    contactStiffness_Mar = 3e6
    contactDamping_Mar = 800

    link_indices_Al = [self.link_name_to_index['Bottom_Link_1'],self.link_name_to_index['Bottom_Link_2'],\
                      self.link_name_to_index['Bottom_Link_3'], self.link_name_to_index['Gamba_Link_1'],\
                      self.link_name_to_index['Gamba_Link_2'], self.link_name_to_index['Gamba_Link_3'],\
                      self.link_name_to_index['Top_core'], self.link_name_to_index['Cover_Link1'], \
                      self.link_name_to_index['Cover_Link_2'], self.link_name_to_index['Cover_Link_3']]

    link_indices_AISI = [self.link_name_to_index['Top_Link_2'], self.link_name_to_index['Top_Link_3'],\
                        self.link_name_to_index['Top_Link_1'], self.link_name_to_index['Colonna_Link_1'],\
                        self.link_name_to_index['Colonna_Link_2'], self.link_name_to_index['Colonna_Link_3']]

    link_indices_Mar = [self.link_name_to_index['Elastic_Joint_Link_1'], self.link_name_to_index['Elastic_Joint_link_2'],\
                        self.link_name_to_index['Elastic_Joint_link_3']]

    # Al 6082
    for link in link_indices_Al:
      p.changeDynamics(self.PIPPA_id, link, lateralFriction=lateralFriction_Al,\
                      restitution=restitution_Al, \
                      spinningFriction= spinningFriction_Al, rollingFriction= rollingFriction_Al,\
                      linearDamping=linearDamping_Al, angularDamping=angularDamping_Al,\
                      contactStiffness = contactStiffness_Al,contactDamping = contactDamping_Al)
    # AISI 304
    for link in link_indices_AISI:
      p.changeDynamics(self.PIPPA_id, link, lateralFriction=lateralFriction_AISI,\
                      restitution=restitution_AISI, \
                      spinningFriction= spinningFriction_AISI, rollingFriction= rollingFriction_AISI,\
                      linearDamping=linearDamping_AISI, angularDamping=angularDamping_AISI,\
                      contactStiffness = contactStiffness_AISI, contactDamping = contactDamping_AISI)
    # MaragiÃ 
    for link in link_indices_AISI:
      p.changeDynamics(self.PIPPA_id, link, lateralFriction=lateralFriction_Mar,\
                      restitution=restitution_Mar, \
                      spinningFriction= spinningFriction_Mar, rollingFriction= rollingFriction_Mar,\
                      linearDamping=linearDamping_Mar, angularDamping=angularDamping_Mar,\
                      contactStiffness = contactStiffness_Mar, contactDamping = contactDamping_Mar)

    #get position and yaw of each leg in rest position
    ##--------------------------------------------------------------------------------------------------------------
    leg_1_index = self.link_name_to_index['Gamba_Link_1']
    leg_2_index = self.link_name_to_index['Gamba_Link_2']
    leg_3_index = self.link_name_to_index['Gamba_Link_3']

    position_leg_1_rest, orientation_leg_1_rest = p.getLinkState(self.PIPPA_id, leg_1_index)[0:2]
    position_leg_2_rest, orientation_leg_2_rest = p.getLinkState(self.PIPPA_id, leg_2_index)[0:2]
    position_leg_3_rest, orientation_leg_3_rest = p.getLinkState(self.PIPPA_id, leg_3_index)[0:2]

    yaw_1_rest = p.getEulerFromQuaternion(orientation_leg_1_rest)[2]
    yaw_2_rest = p.getEulerFromQuaternion(orientation_leg_2_rest)[2]
    yaw_3_rest = p.getEulerFromQuaternion(orientation_leg_3_rest)[2]

    #get rest state in the same form of rest state
    state_rest = list(position_leg_1_rest) + [yaw_1_rest] + list(position_leg_2_rest) + \
    [yaw_2_rest] + list(position_leg_3_rest) + [yaw_3_rest]
    self.state_rest = np.array(state_rest)

    return self.PIPPA_id

  def reset(self):
    #    print("-----------reset simulation---------------")
    if self._physics_client_id < 0:
      if self._renders:
        self._p = bc.BulletClient(connection_mode=p.GUI)
      else:
        self._p = bc.BulletClient()
      self._physics_client_id = self._p._client

      p = self._p
        
      #allow to find the assets (URDF, obj, textures etc)
      p.setAdditionalSearchPath(pd.getDataPath())
      p.resetSimulation()

      ## loading PIPPA in the origin
      self.pippa_id = self.load_pippa()
      print(f"Resetting environment with pippa_id: {self.pippa_id}")
      self.timeStep = 0.02
      p.setGravity(0, 0, -9.8)
      p.setTimeStep(self.timeStep)
      p.setRealTimeSimulation(0)

    p = self._p

    ##get PIP in random state applying random force to the bottom bars
     ##--------------------------------------------------------------------------------------------------------

     #get legs index
    leg_1_index = self.link_name_to_index['Gamba_Link_1']
    leg_2_index = self.link_name_to_index['Gamba_Link_2']
    leg_3_index = self.link_name_to_index['Gamba_Link_3']

    #get bottom bars index
    bottom_link_1_index = self.link_name_to_index['Bottom_Link_1']
    print("index of bottom link: {bottom_link_1_index}")
    bottom_link_2_index = self.link_name_to_index['Bottom_Link_2']
    bottom_link_3_index = self.link_name_to_index['Bottom_Link_3']

    #get bottom bar position to apply forces there
    position_bottom_1, _ = p.getLinkState(self.pippa_id, bottom_link_1_index)[0:2]
    position_bottom_2, _ = p.getLinkState(self.pippa_id, bottom_link_2_index)[0:2]
    position_bottom_3, _ = p.getLinkState(self.pippa_id, bottom_link_3_index)[0:2]

    #apply random force to the bottom bars
    fx, fy = random.uniform(0, 1), random.uniform(0, 1)
    force_module = np.array([fx,fy,0])
    force_position_1 = position_bottom_1
    force_position_2 = position_bottom_2
    force_position_3 = position_bottom_3

    #apply external forces to the bottom edges of the disk
    p.applyExternalForce(
        objectUniqueId=self.pippa_id,linkIndex= self.link_name_to_index['Bottom_Link_1'],forceObj=force_module, \
        posObj=force_position_1,flags=p.WORLD_FRAME)
    p.applyExternalForce(
        objectUniqueId=self.pippa_id,linkIndex= self.link_name_to_index['Bottom_Link_2'],forceObj=force_module,\
        posObj=force_position_2,flags=p.WORLD_FRAME)
    p.applyExternalForce(
        objectUniqueId=self.pippa_id,linkIndex= self.link_name_to_index['Bottom_Link_3'],forceObj=force_module, \
        posObj=force_position_3,flags=p.WORLD_FRAME)

    for _ in range(1000):
        p.stepSimulation()  # Aggiorna la simulazione
        time.sleep(1./240.)  # Ritardo per simulare 240 Hz


    #get legs random positions after random force
    position_leg_1, orientation_leg_1 = p.getLinkState(self.pippa_id, leg_1_index)[0:2]
    position_leg_2, orientation_leg_2 = p.getLinkState(self.pippa_id, leg_2_index)[0:2]
    position_leg_3, orientation_leg_3 = p.getLinkState(self.pippa_id, leg_3_index)[0:2]

    #get euler angles, just yaw needed
    yaw_1 = p.getEulerFromQuaternion(orientation_leg_1)[2]
    yaw_2 = p.getEulerFromQuaternion(orientation_leg_2)[2]
    yaw_3 = p.getEulerFromQuaternion(orientation_leg_3)[2]

    # BUROCRAZIA in order to avoid useless complains
    state_list = list(position_leg_1) + [yaw_1] + list(position_leg_2) + [yaw_2] + list(position_leg_3) + [yaw_3]

    #state array
    self.state = np.array(state_list)
    return np.array(self.state)


  def step(self, action):
    p = self._p

    #comnplains to humans
    err_msg = f"{action!r} ({type(action)}) invalid"
    assert self.action_space.contains(action), err_msg
    assert self.state is not None, "Call reset before using step method."

    #force to be applied
    action_x, action_y = action[0], action[1]
    force_module = np.array([action_x, action_y,0])

    #get bottom bar position to apply forces there
    position_bottom_1, _ = p.getLinkState(self.pippa_id, self.link_name_to_index['Bottom_Link_1'])[0:2]
    position_bottom_2, _ = p.getLinkState(self.pippa_id, self.link_name_to_index['Bottom_Link_2'])[0:2]
    position_bottom_3, _ = p.getLinkState(self.pippa_id, self.link_name_to_index['Bottom_Link_3'])[0:2]

    #apply external forces to the bottom edges of the disk
    p.applyExternalForce(
        objectUniqueId=self.pippa_id,linkIndex= self.link_name_to_index['Bottom_Link_1'],forceObj=force_module, \
        posObj=position_bottom_1,flags=p.WORLD_FRAME)
    p.applyExternalForce(
        objectUniqueId=self.pippa_id,linkIndex= self.link_name_to_index['Bottom_Link_2'],forceObj=force_module,\
        posObj=position_bottom_2,flags=p.WORLD_FRAME)
    p.applyExternalForce(
        objectUniqueId=self.pippa_id,linkIndex= self.link_name_to_index['Bottom_Link_3'],forceObj=force_module, \
        posObj=position_bottom_3,flags=p.WORLD_FRAME)

    #calculate next state
    p.stepSimulation()

    #get state after force
    position_leg_1, orientation_leg_1 = p.getLinkState(self.pippa_id, self.link_name_to_index['Gamba_Link_1'])[0:2]
    position_leg_2, orientation_leg_2 = p.getLinkState(self.pippa_id, self.link_name_to_index['Gamba_Link_2'])[0:2]
    position_leg_3, orientation_leg_3 = p.getLinkState(self.pippa_id, self.link_name_to_index['Gamba_Link_3'])[0:2]

    #get yaw
    yaw_1 = p.getEulerFromQuaternion(orientation_leg_1)[2]
    yaw_2 = p.getEulerFromQuaternion(orientation_leg_2)[2]
    yaw_3 = p.getEulerFromQuaternion(orientation_leg_3)[2]

    # state after force
    next_state_list = list(position_leg_1) + [yaw_1] + list(position_leg_2) + [yaw_2] + list(position_leg_3) + [yaw_3]
    self.state = np.array(next_state_list)

    #calculate linear and angular distance for termination
    self.distance_linear_1 = np.linalg.norm(self.state[0:3] - self.state_rest[0:3])
    self.distance_linear_2 = np.linalg.norm(self.state[4:7] - self.state_rest[4:7])
    self.distance_linear_3 = np.linalg.norm(self.state[8:11] - self.state_rest[8:11])

    self.distance_angular_1 = np.abs(self.state[3] - self.state_rest[3])
    self.distance_angular_2 = np.abs(self.state[7] - self.state_rest[7])
    self.distance_angular_3 = np.abs(self.state[11] - self.state_rest[11])

    #check for dones
    done =  self.distance_linear_1 > self.threshold_distance \
                or self.distance_linear_2 > self.threshold_distance \
                or self.distance_linear_3 > self.threshold_distance \
                or self.distance_angular_1 > self.threshold_yaw \
                or self.distance_angular_2 > self.threshold_yaw \
                or self.distance_angular_3 > self.threshold_yaw
    done = bool(done)

    #assign reward
    reward = 1.0 if not done else 0.0

    #print("state=",self.state)
    return np.array(self.state), reward, done, {}


  def render(self, mode='human', close=False):
    if mode == "human":
      self._renders = True
    if mode != "rgb_array":
      return np.array([])
    base_pos=[0,0,0]
    self._cam_dist = 2.5
    self._cam_pitch = -10.0
    self._cam_yaw = 0
    if (self._physics_client_id>=0):
      view_matrix = self._p.computeViewMatrixFromYawPitchRoll(
        cameraTargetPosition=base_pos,
        distance=self._cam_dist,
        yaw=self._cam_yaw,
        pitch=self._cam_pitch,
        roll=0,
        upAxisIndex=2)
      proj_matrix = self._p.computeProjectionMatrixFOV(fov=60,
             aspect=float(self._render_width) /
             self._render_height,
             nearVal=0.1,
             farVal=100.0)
      (_, _, px, _, _) = self._p.getCameraImage(
          width=self._render_width,
          height=self._render_height,
          renderer=self._p.ER_BULLET_HARDWARE_OPENGL,
          viewMatrix=view_matrix,
          projectionMatrix=proj_matrix)
    else:
      px = np.array([[[255,255,255,255]]*self._render_width]*self._render_height, dtype=np.uint8)
    rgb_array = np.array(px, dtype=np.uint8)
    rgb_array = np.reshape(np.array(px), (self._render_height, self._render_width, -1))
    rgb_array = rgb_array[:, :, :3]
    return rgb_array

  def configure(self, args):
    pass

  def close(self):
    if self._physics_client_id >= 0:
      self._p.disconnect()
    self._physics_client_id = -1

